# Import dependencies
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
import sklearn.metrics as metrics
import pandas as pd
import numpy as np

# Generating regression dataset from sklearn.datasets
def Data_Collection(n_samples, n_features, n_targets, noise, random_state=42):
    # Use the following values: n_samples = 1000, n_features = 3, n_targets = 1,
    # noise = 0.01, random_state = 42
    ds = datasets.make_regression(n_samples=n_samples,
                            n_features=n_features,
                            n_targets=n_targets,
                            noise=noise,
                            random_state=random_state)
    # Creating Pandas dataframes from dataset generated by sklearn.datasets
    X = pd.DataFrame(ds[0], columns=["feature1", "feature2", "feature3"])
    y = pd.DataFrame(ds[1], columns=["target"])
    return X, y

# Splitting X and y into train and test datasets
def Train_Test_Split(X, y, test_size, random_state=42):
    # Use the following values: X = X, y = y, test_size = 0.33, random_state = 42
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state)
    return X_train, X_test, y_train, y_test

# Creating the Multiple Linear Regression model
def Model_Building(model, X_train, y_train):
    # Use the following values: model = LinearRegression(), X_train = X_train, y_train = y_train
    reg = model
    reg.fit(X_train, y_train)
    return reg

# Creating prediction on test dataset
def Prediction(model, data):
    # Use the following values: model = reg, data = X_test
    pred = model.predict(data)
    return pred

# Metrics to evaluate regression model
def Evaluation(y_true, y_pred, metric):
    # Use the following values: y_true = y_test, y_pred = pred, metric = "MSE"
    eval = metric
    if eval == "MSE":
        MSE = metrics.mean_squared_error(y_true, y_pred)
        return MSE
    elif eval == "RMSE":
        MSE = metrics.mean_squared_error(y_true, y_pred)
        RMSE = np.sqrt(MSE)
        return RMSE
    else:
        return "The following metric is not available"