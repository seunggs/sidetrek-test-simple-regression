# Import dependencies
import typing
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.base import RegressorMixin
import sklearn.metrics as metrics
import pandas as pd
import numpy as np
from dataclasses import dataclass


@dataclass
class Hyperparameters(object):
    """
    n_samples
    n_features
    n_targets
    noise
    random_state
    test_size
    metric
    """

    n_samples: int = 1000
    n_features: int = 3
    n_targets: int = 1
    noise: float = 0.01
    random_state: int = 42
    test_size: float = 0.33
    metric: str = "MSE"


# Generating regression dataset from sklearn.datasets
def collect_data(n_samples: int, n_features: int, n_targets: int, noise: float, random_state: int = 42) -> typing.Tuple[pd.DataFrame, pd.DataFrame]:
    # Use the following values: n_samples = 1000, n_features = 3, n_targets = 1,
    # noise = 0.01, random_state = 42
    ds = datasets.make_regression(n_samples=n_samples, n_features=n_features, n_targets=n_targets, noise=noise, random_state=random_state)
    # Creating Pandas dataframes from dataset generated by sklearn.datasets
    X = pd.DataFrame(ds[0], columns=["feature1", "feature2", "feature3"])
    y = pd.DataFrame(ds[1], columns=["target"])
    return X, y


# Splitting X and y into train and test datasets
def split_train_test(X: pd.DataFrame, y: pd.DataFrame, test_size: float, random_state: int = 42) -> typing.Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    # Use the following values: X = X, y = y, test_size = 0.33, random_state = 42
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state)
    return X_train, X_test, y_train, y_test


# Creating the Multiple Linear Regression model
def build_model(X_train: pd.DataFrame, y_train: pd.DataFrame) -> RegressorMixin:
    # Use the following values: model = LinearRegression(), X_train = X_train, y_train = y_train
    model = LinearRegression()
    reg = model
    reg.fit(X_train, y_train)
    return reg


# Creating prediction on test dataset
def predict(model: RegressorMixin, data: pd.DataFrame) -> np.ndarray:
    # Use the following values: model = reg, data = X_test
    pred = model.predict(data)
    return pred


# Metrics to evaluate regression model
def evaluate(y_true: pd.DataFrame, y_pred: np.ndarray, metric: str = "MSE") -> float:
    # Use the following values: y_true = y_test, y_pred = pred, metric = "MSE"
    if metric == "MSE":
        return metrics.mean_squared_error(y_true, y_pred)
    elif metric == "RMSE":
        mse = metrics.mean_squared_error(y_true, y_pred)
        return np.sqrt(mse)
    else:
        raise Exception("The following metric is not available")
